import { Router } from 'express';
import multer from 'multer';
import { z } from 'zod';
import { DocumentAnalysisService } from '../services/documentAnalysis';
import { getSupabase } from '../lib/supabase';
import { UploadService } from '../services/upload';
import {
  extractDocxPlaceholders,
  extractPdfPlaceholders,
  extractTextPlaceholders,
} from '../services/templateParser';
import {
  listCanonicalMergeFields,
  normalizePlaceholders,
} from '../services/templateNormalizer';
import type { CanonicalMergeFieldDefinition } from '../services/templateNormalizer';
import { requireAuth } from '../middleware/auth';
import { adminLimiter } from '../middleware/rateLimit';

const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 15 * 1024 * 1024 } });

const router = Router();
let documentAnalysis: DocumentAnalysisService | null = null;
let uploadService: UploadService | null = null;

function getDocumentAnalysis(): DocumentAnalysisService {
  if (!documentAnalysis) {
    documentAnalysis = new DocumentAnalysisService();
  }
  return documentAnalysis;
}

function getUploadService(): UploadService {
  if (!uploadService) {
    uploadService = new UploadService();
  }
  return uploadService;
}

// Validation schemas
const analyzeTemplateSchema = z.object({
  googleDocId: z.string().min(1, 'Google Doc ID is required'),
  projectId: z.string().uuid().optional(),
  version: z.string().default('v1')
});
const uploadTemplateSchema = z.object({
  projectId: z.string().uuid(),
  templateType: z.enum(['submission_format', 'grounds', 'council_email', 'supporter_email', 'followup_grounds', 'combined_grounds']),
  version: z.string().default('v1'),
  versionNotes: z.string().optional(),
  canonicalMappings: z.record(z.string()).optional()
});

const canonicalFieldSchema = z.object({
  canonical: z.string().optional()
});

const validateTemplateSchema = z.object({
  googleDocId: z.string().min(1, 'Google Doc ID is required')
});

const generateSurveySchema = z.object({
  googleDocId: z.string().min(1, 'Google Doc ID is required'),
  projectId: z.string().uuid('Invalid project ID'),
  version: z.string().default('v1'),
  saveToDatabase: z.boolean().default(true)
});

/**
 * Validate a Google Doc template (admin only)
 * GET /api/templates/validate?googleDocId=xxx
 */
router.get('/validate', async (req, res) => {
  try {
    const { googleDocId } = validateTemplateSchema.parse(req.query);
    
    const validation = await getDocumentAnalysis().validateTemplate(googleDocId);
    
    res.json({
      success: true,
      data: validation
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message || 'Template validation failed'
    });
  }
});

/**
 * Preview analysis of a Google Doc template
 * GET /api/templates/preview?googleDocId=xxx
 */
router.get('/preview', async (req, res) => {
  try {
    const { googleDocId } = validateTemplateSchema.parse(req.query);
    
    const previewResult = await getDocumentAnalysis().previewAnalysis(googleDocId);
    
    res.json({
      success: true,
      data: previewResult
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message || 'Template preview failed'
    });
  }
});

/**
 * Analyze a Google Doc and extract concerns
 * POST /api/templates/analyze
 */
router.post('/analyze', async (req, res) => {
  try {
    const { googleDocId, projectId, version } = analyzeTemplateSchema.parse(req.body);
    
    // Perform analysis
    const analysisResult = await getDocumentAnalysis().analyzeGroundsTemplate(googleDocId);
    
    // Optionally save to database if projectId provided
    let savedConcerns = null;
    if (projectId) {
      try {
        savedConcerns = await getDocumentAnalysis().generateSurveyFromAnalysis(
          analysisResult,
          projectId,
          version
        );
      } catch (saveError: any) {
        console.warn('Failed to save concerns to database:', saveError.message);
        // Continue without saving - return analysis result anyway
      }
    }
    
    res.json({
      success: true,
      data: {
        analysis: analysisResult,
        savedConcerns: savedConcerns || undefined
      }
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message || 'Document analysis failed'
    });
  }
});

/**
 * Generate and save survey from analyzed document
 * POST /api/templates/generate-survey
 */
router.post('/generate-survey', async (req, res) => {
  try {
    const { googleDocId, projectId, version, saveToDatabase } = generateSurveySchema.parse(req.body);
    
    // First analyze the document
    const analysisResult = await getDocumentAnalysis().analyzeGroundsTemplate(googleDocId);
    
    let savedConcerns = null;
    if (saveToDatabase) {
      savedConcerns = await getDocumentAnalysis().generateSurveyFromAnalysis(
        analysisResult,
        projectId,
        version
      );
    }
    
    res.json({
      success: true,
      data: {
        analysis: analysisResult,
        concerns: savedConcerns || analysisResult.extractedConcerns,
        generated: saveToDatabase
      }
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message || 'Survey generation failed'
    });
  }
});

/**
 * Upload a template file
 * POST /api/templates/upload
 */
router.post('/upload', upload.single('file'), async (req, res) => {
  try {
    const body = uploadTemplateSchema.parse({ ...req.body, canonicalMappings: req.body?.canonicalMappings ? JSON.parse(req.body.canonicalMappings) : undefined });
    if (!req.file) {
      return res.status(400).json({ success: false, error: 'File is required' });
    }

    const fileResult = await getUploadService().uploadTemplateFile(
      body.projectId,
      body.templateType,
      req.file.buffer,
      req.file.mimetype,
      req.file.originalname
    );

    const placeholderSummary = await summarizePlaceholders(
      req.file.buffer,
      req.file.mimetype,
      body.canonicalMappings || {}
    );

    const supabase = getSupabase();
    if (!supabase) {
      return res.status(500).json({ success: false, error: 'Database not configured' });
    }

    const { data: templateFile, error: upsertError } = await supabase
      .from('template_files')
      .upsert({
        project_id: body.projectId,
        template_type: body.templateType,
        updated_at: new Date().toISOString(),
      }, {
        onConflict: 'project_id,template_type'
      })
      .select()
      .single();

    if (upsertError) {
      throw new Error(upsertError.message);
    }

    const { data: version, error: versionError } = await supabase
      .from('template_versions')
      .insert({
        template_file_id: templateFile.id,
        version_label: body.version,
        storage_path: fileResult.storagePath,
        mimetype: fileResult.mimetype,
        original_filename: fileResult.originalFilename,
        merge_fields: placeholderSummary.placeholders,
        version_notes: body.versionNotes,
      })
      .select()
      .single();

    if (versionError) {
      throw new Error(versionError.message);
    }

    await supabase
      .from('template_files')
      .update({ active_version_id: version.id })
      .eq('id', templateFile.id);

    res.status(201).json({
      success: true,
      data: {
        version,
        placeholders: placeholderSummary.placeholders,
        canonicalFields: placeholderSummary.canonical_fields,
      },
    });
  } catch (error: any) {
    res.status(400).json({ success: false, error: error.message || 'Template upload failed' });
  }
});

type UploadPlaceholderSummary = {
  placeholders: Array<{ placeholder: string; canonical_field?: string }>;
  canonical_fields: CanonicalMergeFieldDefinition[];
};

async function summarizePlaceholders(
  buffer: Buffer,
  mimetype: string,
  mapping: Record<string, string>
) : Promise<UploadPlaceholderSummary> {
  const summary = await extractPlaceholders(buffer, mimetype);

  const normalized = normalizePlaceholders(summary.placeholders.map(({ placeholder }) => placeholder));

  const merged = normalized.map(({ placeholder, canonical_field }) => ({
    placeholder,
    canonical_field: mapping[placeholder] || canonical_field,
  }));

  return {
    placeholders: merged,
    canonical_fields: listCanonicalMergeFields(),
  };
}

async function extractPlaceholders(buffer: Buffer, mimetype: string) {
  if (mimetype === 'application/pdf') {
    return extractPdfPlaceholders(buffer);
  }

  if (
    mimetype ===
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
    mimetype === 'application/msword'
  ) {
    return extractDocxPlaceholders(buffer);
  }

  return extractTextPlaceholders(buffer.toString('utf8'));
}

/**
 * Get existing concern templates for a version
 * GET /api/templates/concerns?version=v1
 */
router.get('/concerns', async (req, res) => {
  try {
    const { version = 'v1' } = req.query;
    const supabase = getSupabase();
    
    if (!supabase) {
      return res.status(500).json({
        success: false,
        error: 'Database not configured'
      });
    }
    
    const { data: concerns, error } = await supabase
      .from('concern_templates')
      .select('*')
      .eq('version', version)
      .eq('is_active', true)
      .order('key');
    
    if (error) {
      throw new Error(error.message);
    }
    
    res.json({
      success: true,
      data: {
        version,
        concerns: concerns || []
      }
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message || 'Failed to fetch concern templates'
    });
  }
});

/**
 * Update or create concern templates
 * PUT /api/templates/concerns
 */
router.put('/concerns', async (req, res) => {
  try {
    const concernsSchema = z.object({
      version: z.string().default('v1'),
      concerns: z.array(z.object({
        key: z.string().min(1),
        label: z.string().min(1),
        body: z.string().min(1),
        is_active: z.boolean().default(true)
      }))
    });
    
    const { version, concerns } = concernsSchema.parse(req.body);
    const supabase = getSupabase();
    
    if (!supabase) {
      return res.status(500).json({
        success: false,
        error: 'Database not configured'
      });
    }
    
    const { data, error } = await supabase
      .from('concern_templates')
      .upsert(concerns.map(concern => ({
        version,
        key: concern.key,
        label: concern.label,
        body: concern.body,
        is_active: concern.is_active
      })), {
        onConflict: 'version,key'
      })
      .select();
    
    if (error) {
      throw new Error(error.message);
    }
    
    res.json({
      success: true,
      data: {
        updated: data?.length || 0,
        concerns: data || []
      }
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message || 'Failed to update concern templates'
    });
  }
});

/**
 * Delete concern template
 * DELETE /api/templates/concerns/:version/:key
 */
router.delete('/concerns/:version/:key', async (req, res) => {
  try {
    const { version, key } = req.params;
    const supabase = getSupabase();
    
    if (!supabase) {
      return res.status(500).json({
        success: false,
        error: 'Database not configured'
      });
    }
    
    const { error } = await supabase
      .from('concern_templates')
      .delete()
      .eq('version', version)
      .eq('key', key);
    
    if (error) {
      throw new Error(error.message);
    }
    
    res.json({
      success: true,
      message: 'Concern template deleted successfully'
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message || 'Failed to delete concern template'
    });
  }
});

router.get('/files/:projectId', async (req, res) => {
  try {
    const { projectId } = req.params;
    const supabase = getSupabase();

    if (!supabase) {
      return res.status(500).json({ success: false, error: 'Database not configured' });
    }

    const { data: files, error } = await supabase
      .from('template_files')
      .select('id, project_id, template_type, active_version_id, updated_at, template_versions(id, version_label, storage_path, mimetype, original_filename, merge_fields, created_at)')
      .eq('project_id', projectId)
      .order('updated_at', { ascending: false });

    if (error) {
      throw new Error(error.message);
    }

    const transformed = (files || []).map((file) => ({
      id: file.id,
      template_type: file.template_type,
      active_version_id: file.active_version_id,
      updated_at: file.updated_at,
      versions: (file.template_versions || []).map((version) => ({
        id: version.id,
        template_file_id: file.id,
        version_label: version.version_label,
        storage_path: version.storage_path,
        mimetype: version.mimetype,
        original_filename: version.original_filename,
        merge_fields: version.merge_fields,
        created_at: version.created_at,
      })),
    }));

    res.json({ success: true, data: transformed });
  } catch (error: any) {
    res.status(400).json({ success: false, error: error.message || 'Failed to list template files' });
  }
});

router.post('/files/:fileId/activate', async (req, res) => {
  try {
    const { fileId } = req.params;
    const { versionId } = req.body;

    if (!versionId) {
      return res.status(400).json({ success: false, error: 'versionId is required' });
    }

    const supabase = getSupabase();
    if (!supabase) {
      return res.status(500).json({ success: false, error: 'Database not configured' });
    }

    const { error: updateError } = await supabase
      .from('template_files')
      .update({ active_version_id: versionId, updated_at: new Date().toISOString() })
      .eq('id', fileId);

    if (updateError) {
      throw new Error(updateError.message);
    }

    res.json({ success: true });
  } catch (error: any) {
    res.status(400).json({ success: false, error: error.message || 'Failed to activate template version' });
  }
});

router.delete('/files/:fileId/version/:versionId', async (req, res) => {
  try {
    const { fileId, versionId } = req.params;
    const supabase = getSupabase();

    if (!supabase) {
      return res.status(500).json({ success: false, error: 'Database not configured' });
    }

    const { error: deleteError } = await supabase
      .from('template_versions')
      .delete()
      .eq('id', versionId)
      .eq('template_file_id', fileId);

    if (deleteError) {
      throw new Error(deleteError.message);
    }

    res.json({ success: true });
  } catch (error: any) {
    res.status(400).json({ success: false, error: error.message || 'Failed to delete template version' });
  }
});

/**
 * Update council email body template for a project
 * PUT /api/templates/email-body/:projectId
 */
router.put('/email-body/:projectId', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { emailBody } = z.object({
      emailBody: z.string().min(1, 'Email body template is required')
    }).parse(req.body);
    
    const supabase = getSupabase();
    if (!supabase) {
      return res.status(500).json({
        success: false,
        error: 'Database not configured'
      });
    }
    
    const { data: project, error } = await supabase
      .from('projects')
      .update({ 
        council_email_body_template: emailBody,
        updated_at: new Date().toISOString()
      })
      .eq('id', projectId)
      .select()
      .single();
    
    if (error) {
      throw new Error(error.message);
    }
    
    res.json({
      success: true,
      data: {
        projectId,
        emailBodyTemplate: project.council_email_body_template
      }
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message || 'Failed to update email body template'
    });
  }
});

/**
 * Get Gold Coast default templates
 * GET /api/templates/defaults/gold-coast
 */
router.get('/defaults/gold-coast', async (req, res) => {
  try {
    const goldCoastDefaults = {
      submissionTemplate: `# Gold Coast Council - Development Application Submission Template

## Property Details
**Lot Number:** {{lot_number}}  
**Plan Number:** {{plan_number}}  
**Property Address:** {{site_address}}  
**Application Number:** {{application_number}}

## Submitter Details  
**First Name:** {{applicant_first_name}}  
**Surname:** {{applicant_last_name}}  

**Residential Address:**  
{{applicant_residential_address}}  
{{applicant_suburb}} {{applicant_state}} {{applicant_postcode}}  
**Email Address:** {{applicant_email}}

## Postal Address
{{#if postal_address_same}}
**Postal Address:** Same as residential address above
{{else}}
**Postal Address:**  
{{applicant_postal_address}}  
{{postal_suburb}} {{postal_state}} {{postal_postcode}}  
**Email Address:** {{postal_email}}
{{/if}}

## Submission Details
**Position on Development Application:** **OBJECTING**

### Grounds of Submission
{{grounds_content}}

The above grounds focus on planning issues and demonstrate how the proposed development is inconsistent with the Gold Coast City Plan.

## Declaration
I understand and acknowledge that:
✓ The information provided in this submission is true and correct  
✓ This submission is NOT confidential and will be displayed through PD Online  
✓ I acknowledge Queensland State Laws will accept this communication as containing my signature

**Electronic Signature:** {{applicant_first_name}} {{applicant_last_name}}  
**Date:** {{submission_date}}`,

      emailTemplate: `Dear {{council_name}},

Attention: Tim Baker CEO,

Please find attached our development application submission in response to Application {{application_number}}.

Property: {{site_address}}
Name: {{applicant_full_name}}
Residential Address: {{applicant_residential_address}}, {{applicant_suburb}} {{applicant_state}} {{applicant_postcode}}
Email: {{applicant_email}}
Position: OBJECTING

This submission outlines community concerns regarding the proposed development and its compliance with the Gold Coast City Plan.

Kind regards,
{{applicant_full_name}}`,

      councilSettings: {
        council_name: 'Gold Coast City Council',
        council_email: 'mail@goldcoast.qld.gov.au',
        council_subject_template: 'Development application submission opposing application number {{application_number}}',
        default_application_number: 'COM/2025/271'
      }
    };
    
    res.json({
      success: true,
      data: goldCoastDefaults
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message || 'Failed to get Gold Coast defaults'
    });
  }
});

export default router;
